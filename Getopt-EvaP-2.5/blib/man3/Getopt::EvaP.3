.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EvaP 3"
.TH EvaP 3 "2013-04-09" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Getopt::EvaP \- evaluate Perl command line parameters.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use vars qw/@PDT @MM %OPT/;
\& use Getopt::EvaP;
.Ve
.PP
.Vb 1
\& EvaP \e@PDT, \e@MM, \e%OPT;
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
\&\f(CW\*(C`use Getopt::EvaP\*(C'\fR exports the subs \f(CW\*(C`EvaP\*(C'\fR and \f(CW\*(C`EvaP_PAC\*(C'\fR into your
name space.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB@PDT\fR
is the Parameter Description Table, which is a reference to a list of
strings describing the command line parameters, aliases,
types and default values.
\&\fB@MM\fR
is the Message Module, which is also a reference to a list of strings
describing the command and it's parameters.
\&\fB%OPT\fR
is an optional hash reference where Evaluate Parameters should place its
results.  If specified, the historical behaviour of modifying the calling
routines' namespace by storing option values in \fB%Options\fR, \fB%options\fR and
\&\fB$opt*\fR is disabled.
.Sh "Introduction"
.IX Subsection "Introduction"
Function Evaluate Parameters parses a Perl command line in a simple and
consistent manner, performs type checking of parameter values, and provides
the user with first-level help.  Evaluate Parameters is also embeddable in
your application; refer to the \fB\f(BIevap_pac\fB\|(2)\fR man page for complete details.
Evaluate Parameters handles command lines in the following format:
.PP
.Vb 1
\&  command [-parameters] [file_list]
.Ve
.PP
where parameters and file_list are all optional.  A typical example is the
C compiler:
.PP
.Vb 1
\&  cc -O -o chunk chunk.c
.Ve
.PP
In this case there are two parameters and a file_list consisting of a
single file name for the cc command.
.Sh "Parameter Description Table (\s-1PDT\s0) Syntax"
.IX Subsection "Parameter Description Table (PDT) Syntax"
Here is the \s-1PDT\s0 syntax.  Optional constructs are enclosed in [], and the
| character separates possible values in a list.
.PP
.Vb 3
\&  PDT [program_name, alias]
\&    [parameter_name[, alias]: type [ = [default_variable,] default_value]]
\&  PDTEND [optional_file_list | required_file_list | no_file_list]
.Ve
.PP
So, the simplest possible \s-1PDT\s0 would be:
.PP
.Vb 2
\&  PDT
\&  PDTEND
.Ve
.PP
This \s-1PDT\s0 would simply define a \fI\-help\fR switch for the command, but is rather
useless. 
.PP
A typical \s-1PDT\s0 would look more like this:
.PP
.Vb 3
\&  PDT frog
\&    number, n: integer = 1
\&  PDTEND no_file_list
.Ve
.PP
This \s-1PDT\s0, for command frog, defines a
single parameter, number (or n), of type integer with a default value of 1.
The \s-1PDTEND\s0 \fIno_file_list\fR indicator indicates that no trailing file_list
can appear on the command line.  Of course, the \fI\-help\fR switch is defined
automatically.
.PP
The
\&\fIdefault_variable\fR
is an environment variable \- see the section Usage Notes
for complete details.
.Sh "Usage Notes"
.IX Subsection "Usage Notes"
Usage is similar to getopt/getopts/newgetopt: define a Parameter
Description Table declaring a list of command line parameters, their
aliases, types and default values.  The command line parameter
\&\fI\-help\fR (alias \fI\-h\fR) is automatically included by Evaluate
Parameters.  After the evaluation the values of the command line
parameters are stored in variable names of the form \fB$opt_parameter\fR,
except for lists which are returned as \fB@opt_parameter\fR, where
\&\fIparameter\fR is the full spelling of the command line parameter.
\&\s-1NOTE:\s0 values are also returned in the hashes \fB%options\fR and
\&\fB%Options\fR, with lists being passed as a reference to a list.
.PP
Of course, you can specify where you want Evaluate Parameters to return its
results, in which case this historical feature of writing into your namespace
is disabled.
.PP
An optional \s-1PDT\s0 line can be included that tells Evaluate Parameters whether
or not trailing file names can appear on the command line after all the
parameters.  It can read \fIno_file_list\fR, \fIoptional_file_list\fR or
\&\fIrequired_file_list\fR and, if not specified, defaults to optional.  Although
placement is not important, this line is by convention the last line of the
\&\s-1PDT\s0 declaration.
.PP
Additionally a Message Module is declared that describes the command
and provides examples.  Following the main help text an optional
series of help text messages can be specified for individual command
line parameters.  In the following sample program all the parameters
have this additional text which describes that parameter's type.  The
leadin character is a dot in column one followed by the full spelling
of the command line parameter.  Use \fI\-full\-help\fR rather than \fI\-help\fR
to see this supplemental information.  This sample program illustrates
the various types and how to use \fB\f(BIEvaP()\fB\fR.  The \fIkey\fR type is a
special type that enumerates valid values for the command line
parameter.  The \fIboolean\fR type may be specified as \s-1TRUE/FALSE\s0,
\&\s-1YES/NO\s0, \s-1ON/OFF\s0 or 1/0.  Parameters of type \fIfile\fR have ~ and \f(CW$HOME\fR
expanded, and default values \fIstdin\fR and \fIstdout\fR converted to `\-'
and `>\-', respectively.  Of special note is the default value
\&\fI$required\fR: when specified, Evaluate Parameters will ensure a value
is specified for that command line parameter.
.PP
All types except \fIswitch\fR may be \fIlist of\fR, like the \fItty\fR parameter below.
A list parameter can be specified multiple times on the command line.
\&\s-1NOTE:\s0 in general you should \s-1ALWAYS\s0 quote components of your lists, even if
they're not type string, since Evaluate Parameters uses eval to parse them.
Doing this prevents eval from evaluating expressions that it shouldn't, such
as file name shortcuts like \f(CW$HOME\fR, and backticked items like `hostname`.
Although the resulting \s-1PDT\s0 looks cluttered, Evaluate Parameters knows what
to do and eliminates superfluous quotes appropriately.
.PP
Finally, you can specify a default value via an environment variable.  If
a command line parameter is not specified and there is a corresponding
environment variable defined then Evaluate Parameters will use the value
of the environment variable.  Examine the \fIcommand\fR parameter for the syntax.
With this feature users can easily customize command parameters to their
liking.   Although the name of the environment variable can be whatever you
choose,  the following scheme is suggested for consistency and to avoid
conflicts in names:  
.IP "\(bu" 4
Use all uppercase characters.
.IP "\(bu" 4
Begin the variable name with D_, to suggest a default variable.
.IP "\(bu" 4
Continue with the name of the command or its alias followed by an underscore.
.IP "\(bu" 4
Complete the variable name with the name of the parameter or its alias.
.PP
So, for example, D_DISCI_DO would name a default variable for the
display_option (do) parameter of the display_command_information
(disci) command.  Works for MS-DOS and Unix.
.SH "Example"
.IX Header "Example"
.Vb 1
\& #!/usr/local/bin/perl
.Ve
.PP
.Vb 1
\& use Getopt::EvaP;
.Ve
.PP
.Vb 13
\& @PDT = split /\en/, <<'end-of-PDT';
\& PDT sample
\&   verbose, v: switch
\&   command, c: string = D_SAMPLE_COMMAND, "ps -el"
\&   scale_factor, sf: real = 1.2340896e-1
\&   millisecond_update_interval, mui: integer = $required
\&   ignore_output_file_column_one, iofco: boolean = TRUE
\&   output, o: file = stdout
\&   queue, q: key plotter, postscript, text, printer, keyend = printer
\&   destination, d: application = `hostname`
\&   tty, t: list of name = ("/dev/console", "/dev/tty0", "/dev/tty1")
\& PDTEND optional_file_list
\& end-of-PDT
.Ve
.PP
.Vb 2
\& @MM = split /\en/, <<'end-of-MM';
\& sample
.Ve
.PP
.Vb 2
\&        A sample program demonstrating typical Evaluate Parameters
\&        usage.
.Ve
.PP
.Vb 1
\&        Examples:
.Ve
.PP
.Vb 55
\&          sample
\&          sample -usage-help
\&          sample -help
\&          sample -full-help
\&          sample -mui 1234
\& .verbose
\&        A switch type parameter emulates a typical standalone
\&        switch. If the switch is specified Evaluate Parameters
\&        returns a '1'.
\& .command
\&        A string type parameter is just a list of characters,
\&        which must be quoted if it contains whitespace. 
\&        NOTE:  for this parameter you can also create and
\&        initialize the environment variable D_SAMPLE_COMMAND to
\&        override the standard default value for this command
\&        line parameter.  All types except switch may have a
\&        default environment variable for easy user customization.
\& .scale_factor
\&        A real type parameter must be a real number that may
\&        contain a leading sign, a decimal point and an exponent.
\& .millisecond_update_interval
\&        An integer type parameter must consist of all digits
\&        with an optional leading sign.  NOTE: this parameter's
\&        default value is $required, meaning that
\&        Evaluate Parameters ensures that this parameter is
\&        specified and given a valid value.  All types except
\&        switch may have a default value of $required.
\& .ignore_output_file_column_one
\&        A boolean type parameter may be TRUE/YES/ON/1 or
\&        FALSE/NO/OFF/0, either upper or lower case.  If TRUE,
\&        Evaluate Parameters returns a value of '1', else '0'.
\& .output
\&        A file type parameter expects a filename.  For Unix
\&        $HOME and ~ are expanded.  For EvaP/Perl stdin and
\&        stdout are converted to '-' and '>-' so they can be
\&        used in a Perl open() function.
\& .queue
\&        A key type parameter enumerates valid values.  Only the
\&        specified keywords can be entered on the command line.
\& .destination
\&        An application type parameter is not type-checked in
\&        any - the treatment of this type of parameter is
\&        application specific.  NOTE:  this parameter' default
\&        value is enclosed in grave accents (or "backticks").
\&        Evaluate Parameters executes the command and uses it's
\&        standard output as the default value for the parameter.
\& .tty
\&        A name type parameter is similar to a string except
\&        that embedded white-space is not allowed.  NOTE: this
\&        parameter is also a LIST, meaning that it can be
\&        specified multiple times and that each value is pushed
\&        onto a Perl LIST variable.  In general you should quote
\&        all list elements.  All types except switch may be
\&        'list of'.
\& end-of-MM
.Ve
.PP
.Vb 1
\& EvaP \e@PDT, \e@MM;              # evaluate parameters
.Ve
.PP
.Vb 1
\& print "\enProgram name:\en  $Options{'help'}\en\en";
.Ve
.PP
.Vb 9
\& if (defined $Options{'verbose'}) {print "\enverbose = $Options{'verbose'}\en";}
\& print "command = \e"$Options{'command'}\e"\en";
\& print "scale_factor  = $Options{'scale_factor'}\en";
\& print "millisecond_update_interval = $Options{'millisecond_update_interval'}\en";
\& print "ignore_output_file_column_one = $Options{'ignore_output_file_column_one'}\en";
\& print "output = $Options{'output'}\en";
\& print "queue = $Options{'queue'}\en";
\& print "destination = $Options{'destination'}\en";
\& print "'list of' tty = \e"", join('", "', @{$Options{'tty'}}), "\e"\en";
.Ve
.PP
.Vb 1
\& print "\enFile names:\en  ", join ' ', @ARGV, "\en" if @ARGV;
.Ve
.PP
Using the \s-1PDT\s0 as a guide, Evaluate Parameters parses a user's
command line, returning the results of the evaluation to global
variables of the form \fB$opt_parameter\fR, \fB@opt_parameter\fR,
\&\fB%Options{'parameter'}\fR or \fB%options{'parameter'}\fR, where \fIparameter\fR
is the full spelling of the command line parameter.
.PP
Of course, you can specify where you want Evaluate Parameters to return its
results, in which case this historical feature of writing into your namespace
is disabled.
.PP
Every command using Evaluate Parameters automatically has a
\&\fI\-help\fR switch which displays parameter help; no special code is
required in your application.
.Sh "Customization of EvaP's Help Output"
.IX Subsection "Customization of EvaP's Help Output"
There are several Help Hook strings that can be altered to customize
\&\fBEvaP\fR's help output.  Currently there is only one general area that can
be customized: usage and error text dealing with the trailing file_list.
For instance, if a command requires one or more trailing file names after
all the command line switches, the default \fI\-help\fR text is:
.PP
.Vb 1
\& file(s) required by this command
.Ve
.PP
Some commands do not want trailing \*(L"file names\*(R", but rather some other
type of information.  An example is \fIdisplay_command_information\fR where
a single Program_Name is expected.  The following code snippet shows
how to do this:
.PP
.Vb 6
\&  $Getopt::EvaP::evap_Help_Hooks{'P_HHURFL'} = " Program_Name\en";
\&  $Getopt::EvaP::evap_Help_Hooks{'P_HHBRFL'} =
\&        "\enA Program_Name is required by this command.\en\en";
\&  $Getopt::EvaP::evap_Help_Hooks{'P_HHERFL'} =
\&        "A trailing Program_Name is required by this command.\en";
\&  EvaP \e@PDT, \e@MM;
.Ve
.PP
As you can see, the hash \fB%evap_Help_Hooks\fR is indexed by a simple
ordinal.  The ordinals are shown below and are mostly self\-explanatory.
In case you don't have access to the source
for Evaluate Parameters, here are the default values of the Help Hook
strings.
.PP
.Vb 12
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHURFL'} = " file(s)\en";
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHUOFL'} = " [file(s)]\en";
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHUNFL'} = "\en";
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHBRFL'} =
\&         "\enfile(s) required by this command\en\en";
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHBOFL'} =
\&        "\en[file(s)] optionally required by this command\en\en";
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHBNFL'} = "\en";
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHERFL'} =
\&        "Trailing file name(s) required.\en";
\&  $Getopt::EvaP:evap_Help_Hooks{'P_HHENFL'} =
\&        "Trailing file name(s) not permitted.\en";
.Ve
.PP
The Help Hooks naming convention is rather simple:
.PP
.Vb 1
\&  P_HHtf
.Ve
.PP
.Vb 1
\&    where:
.Ve
.PP
.Vb 9
\&      P_HH  implies an Evaluate Parameters Help Hook
\&     t     type:
\&              U=Usage Help
\&              B=Brief and Full Help
\&              E=error message
\&      f     file_list:
\&              RFL=required_file_list
\&              OFL=optional_file_list
\&              NFL=no_file_list
.Ve
.PP
Note to \fIgenPerlTk\fR and \fIgenTclTk\fR users:  using these Help Hooks may 
cause the \*(L"genTk programs\*(R" to generate an unuseable Tk script.  This 
happens because the \*(L"genTk programs\*(R" look for the strings \*(L"required by
this command\*(R" or \*(L"optionally required by this command\*(R" in order to 
generate the file_list Entry widget \- if these string are missing the
widget is not created.  An easy solution is to ensure that your Help 
Hook text contains said string, just like the code snippet above;
otherwise you must manually add the required Tk code yourself.
.Sh "Human Interface Guidelines"
.IX Subsection "Human Interface Guidelines"
To make Evaluate Parameters successful, you, the application developer, must
follow certain conventions when choosing parameter names and aliases.
.PP
Parameter names consist of one or more words, separated by underscores, and
describe the parameter (for example, \fIverbose\fR and \fIspool_directory\fR).
.PP
You can abbreviate parameters:  use the first letter of each word in the
parameter name.  Do not use underscores.  For example, you can abbreviate
\&\fIcommand\fR as \fIc\fR and \fIdelay_period\fR as \fIdp\fR.
.PP
There are exceptions to this standard:
.IP "\(bu" 4
\&\fIpassword\fR is abbreviated \fIpw\fR.
.IP "\(bu" 4
The words \fIminimum\fR and \fImaximum\fR are abbreviated
\&\fImin\fR and \fImax\fR.  So, the abbreviation for the
parameter \fImaximum_byte_count\fR is \fImaxbc\fR.
.IP "\(bu" 4
There are no abbreviations for the parameters
\&\fIusage-help\fR and \fIfull-help\fR; I do not want to
prevent \fIuh\fR and \fIfh\fR from being used as valid
command line parameters.
.Sh "Variables \s-1MANPAGER\s0, \s-1PAGER\s0 and D_EVAP_DO_PAGE"
.IX Subsection "Variables MANPAGER, PAGER and D_EVAP_DO_PAGE"
The environment variable \s-1MANPAGER\s0 (or \s-1PAGER\s0) is used to control the
display of help information generated by Evaluate Parameters.  If
defined and non\-null, the value of the environment variable is taken as
the name of the program to pipe the help output through.  If no paging
program is defined then the program \fImore\fR is used.
.PP
The boolean environment variable D_EVAP_DO_PAGE can be set to \s-1FALSE/NO/OFF/0\s0,
any case, to disable this automatic paging feature (or you can set your
paging program to \fIcat\fR).
.Sh "Return Values"
.IX Subsection "Return Values"
\&\fB\f(BIEvaP()\fB\fR behaves differently depending upon whether it's called to parse an 
application's command line, or as an embedded command line parser
(for instance, when using \fB\f(BIevap_pac()\fB\fR).
.PP
.Vb 6
\&            Application      Embedded
\&            Command Line     Command Line 
\& ----------------------------------------
\& error      exit(1)          return(0)
\& success    return(1)        return(1)
\& help       exit(0)          return(-1)
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 11
\& evap(2)
\& evap.c(2)
\& EvaP.pm(2)
\& evap.tcl(2)
\& evap_pac(2)
\& addmm, add_message_modules(1)
\& disci, display_command_information(1)
\& genmp, generate_man_page(1)
\& genpdt, generate_pdt(1)
\& genPerlTk, generate_PerlTk_program(1)
\& genTclTk, generate_TclTk_program(1)
.Ve
.PP
.Vb 1
\& All available from directory F<ftp://ftp.Lehigh.EDU:/pub/evap/evap-2.x/>.
.Ve
.SH "BUGS"
.IX Header "BUGS"
The code is messy (written in Perl4\-ese), and should be redone, but I
can't rationalize the time expenditure for code that still works so well.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen.O.Lidie@Lehigh.EDU
.SH "HISTORY"
.IX Header "HISTORY"
.Vb 3
\& lusol@Lehigh.EDU 94/10/28 (PDT version 2.0)  Version 2.2
\&   . Original release - derived from evap.pl version 2.1.
\&   . Undef option values for subsequent embedded calls.
.Ve
.PP
.Vb 8
\& lusol@Lehigh.EDU 95/10/27 (PDT version 2.0)  Version 2.3.0
\&   . Be a strict as possible.
\&   . Revert to -h alias rather than -?.  (-? -?? -??? still available.)
\&   . Move into Getopt class.
\&   . Format for 80 columns (mostly).
\&   . Optional third argument on EvaP call can be a reference to your own
\&     %Options hash.  If specified, the variabes %Options, %options and 
\&     $opt* are not used.
.Ve
.PP
.Vb 3
\& lusol@Lehigh.EDU 97/01/12 (PDT version 2.0)  Version 2.3.1
\&   . Fix Makefile.PL so it behaves properly.  Convert nroff man data to pod
\&     format.
.Ve
.PP
.Vb 2
\& Stephen.O.Lidie@Lehigh.EDU 98/01/14 (PDT version 2.0)  Version 2.3.2
\&   . Incorporate Achim Bohnet's POD patch while updating for Win32.
.Ve
.PP
.Vb 7
\& Stephen.O.Lidie@Lehigh.EDU 98/07/25 (PDT version 2.0)  Version 2.3.3
\&   . Update Makefile.PL so it works in the standard fashion.
\&   . Update for perl 5.005 and Tk 800.008.
\&   . Remove use of ENGLISH.
\&   . Add genpTk to generate a Perl/TK GUI wrapper around command line
\&     programs.  Primarily for users of EvaP(), can be used by other codes
\&     as well.
.Ve
.PP
.Vb 2
\& Stephen.O.Lidie@Lehigh.EDU 99/04/03 (PDT version 2.0)  Version 2.3.5
\&   . Update Makefile.PL for ActiveState, fix a -w message found by 5.005_03.
.Ve
.PP
.Vb 3
\& sol0@lehigh.edu 2010/01/19 (PDT version 2.0)  Version 2.3.6
\&   . Patch by Avner Moshkovitz to handle embedded quotes and spaces in string
\&     options.
.Ve
.PP
.Vb 10
\& sol0@lehigh.edu 2013/04/06 (PDT version 2.0)  Version 2.5
\&   . Change -full_help and -usage_help to -full-help and -usage-help (change
\&     underscore to dash).
\&   . Evap_PAC obeys IGNOREEOF.
\&   . Embed the disac and ! MMs and PDTs in the code.
\&   . Messages now use a longer output line widths.
\&   . Use fewer empty lines for -full-help output.
\&   . Allow "help" and "h" to stand for "disac -do f".
\&   . Evap_PAC now ensures that an application command exists.
\&   . disac now determines length of longest command for a tidy column display.
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1993 \- 2013 Stephen O. Lidie. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
